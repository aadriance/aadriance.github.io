<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <meta content="#ffffff" name="theme-color" />
  <meta content="#da532c" name="msapplication-TileColor" />

  
  <link href='&#x2F;icons&#x2F;site.webmanifest' rel="manifest" />
  
  
  <link color="#5bbad5" href='&#x2F;icons&#x2F;safari-pinned-tab.svg' rel="mask-icon" />
  
  
  <link href='&#x2F;icons&#x2F;favicon-16x16.png' rel="icon" sizes="16x16" type="image/png" />
  
  
  <link href='&#x2F;icons&#x2F;favicon-32x32.png' rel="icon" sizes="32x32" type="image/png" />
  
  
  <link href='&#x2F;icons&#x2F;apple-touch-icon.png' rel="apple-touch-icon" sizes="180x180" />
  

  

  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.1/css/academicons.min.css" integrity="sha384-FIue+PI4SsI9XfHCz8dBLg33b0c1fMJgNU3X//L26FYbGnlSEfWmNT7zgWc2N9b6" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link href="https://www.andrewadriance.com/deep-thought.css" rel="stylesheet" />
  
  

  <title>
    
Andrew Adriance | I Have Spent Far Too Long Thinking About FizzBuzz

  </title>

  
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-CZSTFH31S7"></script>
  <script type="text/javascript">
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());
    gtag("config", "G-CZSTFH31S7");
  </script>
  
  

  
</head>

<body class="has-background-white">
  <nav aria-label="section navigation" class="navbar is-light" role="navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-size-5 has-text-weight-bold" href="https:&#x2F;&#x2F;www.andrewadriance.com">Andrew Adriance</a>
        <a aria-expanded="false" aria-label="menu" class="navbar-burger burger" data-target="navMenu" role="button">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div class="navbar-menu" id="navMenu">
        <div class="navbar-end has-text-centered">
          
          
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;www.andrewadriance.com&#x2F;">
            Home
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;www.andrewadriance.com&#x2F;curriculum">
            Curriculum Vitae
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;www.andrewadriance.com&#x2F;posts">
            Posts
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;www.andrewadriance.com&#x2F;tags">
            Tags
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;www.andrewadriance.com&#x2F;categories">
            Categories
          </a>
          
          
          
          <a class="navbar-item" id="nav-search" title="Search" data-target="#search-modal">
            <span class="icon">
              <i class="fas fa-search"></i>
            </span>
          </a>
          <a class="navbar-item" id="dark-mode" title="Switch to dark theme">
            <span class="icon">
              <i class="fas fa-adjust"></i>
            </span>
          </a>
        </div>
      </div>
    </div>
  </nav>

  
  

  
<section class="section">
  <div class="container">
    <div class="columns">
      <div class="column is-8 is-offset-2">
        <article class="box">
          <h1 class="title">
            I Have Spent Far Too Long Thinking About FizzBuzz
          </h1>
          <p class="subtitle"></p>
          <div class="columns is-multiline is-gapless">
            <div class="column is-8">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="fas fa-user"></i>
  </span>
  <span>Andrew Adriance published on</span>
  <span class="icon">
    <i class="far fa-calendar-alt"></i>
  </span>
  <span><time datetime="2022-06-19">June 19, 2022</time></span>
</span>

            </div>
            <div class="column is-4 has-text-right-desktop">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="far fa-clock"></i>
  </span>
  <span>14 min,</span>
  <span class="icon">
    <i class="fas fa-pencil-alt"></i>
  </span>
  <span>2645 words</span>
</span>

            </div>
            <div class="column">
              
              
<p>
  Categories:
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://www.andrewadriance.com/categories/programming/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-cube"></i>
      </span>
      <span>programming</span>
    </span>
  </a>
  
</p>

              
            </div>
            <div class="column has-text-right-desktop">
              
              
<p>
  Tags:
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://www.andrewadriance.com/tags/open-source/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>open source</span>
    </span>
  </a>
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://www.andrewadriance.com/tags/rust/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>rust</span>
    </span>
  </a>
  
</p>

              
            </div>
          </div>
          <div class="content mt-2">
            <p>Welcome brave reader. It's dangerous to go along without context. Take <a href="https://github.com/aadriance/fizzbuzzinator">this pointer</a> to the source of truth on GitHub.</p>
<span id="continue-reading"></span>
<p>For those seeking after the meat of the matter, please detour around my recounting of clarity, for I am aware you have important things needing attention, and I wouldn't desire you waste a moment longer than needed not consuming the important details of my exploratory work on FizzBuzz.</p>
<h2 id="a-rare-moment-of-clarity">A Rare Moment of Clarity</h2>
<p>We have all found ourselves sipping a cup of coco whilst forcing our computer to compute FizzBuzz one billion times to satisfy our deeply unjustified urge to answer the question of what FizzBuzz implementation has the best performance. In that peaceful moment as your fingers halt their march to the deranged orders of a brain consumed by a basic programming problem you might wonder how it all came to this.</p>
<p>For one fateful evening I happened across <a href="https://themonadreader.files.wordpress.com/2014/04/fizzbuzz.pdf">&quot;FizzBuzz in Haskell by Embedding a Domain-Specific Language&quot;</a>. In that moment my brain became infected. In that moment I knew that I could make FizzBuzz unnecessarily contrived. It is a cruel thing to enlighten a programmer to new problems that can be complicated further. I was propelled forth to write implementations of FizzBuzz, and what good would many implementations of the same algorithm be if one did not race them to determine which was superior?</p>
<p>Was this a waste of time? Undoubtedly. It did propel me to write this first blog post, and perhaps that makes all the difference. Although I seriously doubt it.</p>
<h2 id="enter-the-fizzbuzzinator">Enter The FizzBuzzinator</h2>
<p>Inspired by my personal father figure hero <a href="https://en.wikipedia.org/wiki/Dr._Heinz_Doofenshmirtz">Dr. Heinz Doofenshmirtz</a>, the FizzBuzzinator is ten implementations of FizzBuzz that all race to compute ten million instances of FizzBuzz. Do that all one hundred times, dump it to a CSV file, and you've got science. At least according to <a href="https://www.reddit.com/r/mythbusters/comments/3wgqgv/the_origin_of_the_remember_kids_the_only/">Adam Savage</a> who got his famous phrase from ballistic expert Alex Jason.</p>
<blockquote>
<p>Remember kids, the only difference between screwing around and science is writing it down!</p>
</blockquote>
<p>Testing Specifics:</p>
<ul>
<li>Each FizzBuzz implementation measured the time to compute FizzBuzz on all numbers 0-10,000,000.</li>
<li>Each FizzBuzz implementation must do this 100 times.</li>
<li>The Average, median, minimum, and maximum times for the implementation are computer from the 100 records.</li>
<li>All times are recorded in seconds.</li>
</ul>
<p>Now onto the FizzBuzz!</p>
<h3 id="a-brute-force-fizzbuzz">A Brute Force FizzBuzz</h3>
<p>FizzBuzz follows these rules when given a number:</p>
<ul>
<li>If the number is divisible by 3, Fizz</li>
<li>If the number is divisible by 5, Buzz</li>
<li>If the number is divisible by both, FizzBuzz</li>
<li>Else return the number</li>
</ul>
<p>Great, let's turn that into a program!</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">brute_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">15 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else if</span><span> num % </span><span style="color:#d08770;">3 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else if</span><span> num % </span><span style="color:#d08770;">5 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        num.</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<p>The implementation is a &quot;brute force&quot; implementation because it is a linear search of the solution space. There are minor optimizations at play, the check for 3 &amp; 5 has been condensed into a check for divisibility by 15. Interestingly order of operations matters for two reasons:</p>
<ul>
<li>If 3 or 5 was checked first, you wouldn't be able to return your answer without checking divisibility by 15.</li>
<li>We can take advantage of the nature of the properties of divisibility. Assuming an unbiased distribution of numbers, more inputs are divisible by 3 than 5. Checking 3 first allows performing less checks on average. More on this later.</li>
</ul>
<p>How did it perform?</p>
<table><thead><tr><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
</tbody></table>
<p>This is our base line, it's all up (or down?) from here!</p>
<h3 id="a-worse-brute-force">A Worse Brute Force</h3>
<p>If &quot;Fizz&quot; is a higher frequency response than &quot;Buzz&quot;, then switching the order of operations should impact performance. Presenting a strategically worse FizzBuzz:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">worsebrute_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">15 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else if</span><span> num % </span><span style="color:#d08770;">5 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else if</span><span> num % </span><span style="color:#d08770;">3 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        num.</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<p>What do the numbers show?</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Worse</td><td style="text-align: left">0.40853067</td><td style="text-align: left">0.4104857</td><td style="text-align: left">0.3998531</td><td style="text-align: left">0.4113386</td></tr>
</tbody></table>
<p>That's worse for sure. Not horrible, but worse.</p>
<p>Considering the nature of FizzBuzz, 1/3 answers will be Fizz, 1/5 will be Buzz, 1/15 will be FizzBuzz. Ish, you have overlap between the Fizz and Buzz ratio with the FizzBuzz ratio. To be precise:</p>
<ul>
<li>1/15(6.6666-%) = FizzBuzz</li>
<li>4/15(26.6666-%) = Fizz </li>
<li>2/15(13.3333-%) = Buzz</li>
<li>8/15(53.3333-%) = Number</li>
</ul>
<p>This can be used to estimate performance of the &quot;brute force&quot; methods.</p>
<p>Normal brute force:</p>
<ul>
<li>1/15 will require one evaluation</li>
<li>4/15 will require two evaluations</li>
<li>10/15 will require three evaluations</li>
<li>Average of 2.6 evaluations</li>
</ul>
<p>Wait why did Buzz and Number get combined? Falling through an if doesn't require an extra computation. I does require an extra jump, but I am counting evaluations here and not branches.</p>
<p>For worse brute:</p>
<ul>
<li>1/15 will require one evaluation</li>
<li>2/15 will require two evaluations</li>
<li>12/15 will require three evaluations</li>
<li>Average of 2.73333- evaluations</li>
</ul>
<p>While similar, the worse brute force implementation on average requires more computations.</p>
<h3 id="an-accumulative-approach">An Accumulative Approach</h3>
<p>As a software engineer one may be acquainted with <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>. The brute force solution is unfortunately damp. Checking for divisibility by 15 is a repetition of an answer that could be ascertained from the combination of results from checking 5 and 3. Here is a DRY version of FizzBuzz that accumulates the results of divisibility checks:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">accumulate_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> result = String::from(&quot;&quot;);
</span><span>    </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">3 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        result += &quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">5 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        result += &quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if</span><span> result.</span><span style="color:#96b5b4;">is_empty</span><span>() {
</span><span>        result += &amp;num.</span><span style="color:#96b5b4;">to_string</span><span>();
</span><span>    }
</span><span>
</span><span>    result
</span><span>}
</span></code></pre>
<p>In order to avoid the repetition the string can be built as the combination of results from the individual check. How does it preform?</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Accumulate</td><td style="text-align: left">0.619932373</td><td style="text-align: left">0.61990625</td><td style="text-align: left">0.6188068</td><td style="text-align: left">0.6226539</td></tr>
</tbody></table>
<p>Oh, a horrible mistake has been made. Why is the clean, DRY, engineered version of FizzBuzz slower?</p>
<p>Strings.</p>
<p>The original implementation consisted of modulus operators, and branching. In the accumulative implementation a string is being dynamically generated. The act of concatenating strings is no simple matter. Memory buffers have to be extended, contents copied, it's a whole affair!</p>
<p>FizzBuzz is not doomed to be waterlogged, there are other data types that can be accumulated besides strings.</p>
<h3 id="accumulating-bits">Accumulating Bits</h3>
<p>Building a string might be natural, as the output is a string, but it's a costly operation. In place of a string FizzBuzz can be thought of as a two bit set of flags. If the first bit is set, Fizz is present, if the second bit is set, Buzz is present, if both bits are set, then both are present and it represents FizzBuzz.</p>
<ul>
<li>0b00 = Number</li>
<li>0b01 = Fizz</li>
<li>0b10 = Buzz</li>
<li>0b11 = FizzBuzz</li>
</ul>
<p>Those bits can represent an index into an array of answers, and side step the string concatenation problem:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">bitaccumulate_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">let</span><span> results: [&amp;</span><span style="color:#b48ead;">str</span><span>; </span><span style="color:#d08770;">3</span><span>] = [&quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;];
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> idx = </span><span style="color:#d08770;">0</span><span>;
</span><span>
</span><span>    </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">3 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        idx += </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">5 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        idx += </span><span style="color:#d08770;">2</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if</span><span> idx == </span><span style="color:#d08770;">0 </span><span>{
</span><span>        num.</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        String::from(results[idx - </span><span style="color:#d08770;">1</span><span>])
</span><span>    }
</span><span>}
</span></code></pre>
<p>That should be a DRY approach rivaling the powers of the Brute implementation.</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Bit Accumulate</td><td style="text-align: left">0.431947604</td><td style="text-align: left">0.4321037</td><td style="text-align: left">0.4271722</td><td style="text-align: left">0.4353882</td></tr>
</tbody></table>
<p>It's in the same ballpark now, but slower. What gives?</p>
<p>Recalling the discussion on the worse brute force implementation, the original brute force method takes 2.6 calculations on average to compute the answer. This bit accumulating approach:</p>
<ul>
<li>Always requires 2 modulus operations.</li>
<li>Always requires 3 checks.</li>
<li>Requires 0-2 addition operations to accumulate bits.</li>
</ul>
<p>This solution is more complicated computationally. It doesn't get the advantage of early returns the brute force implementation offers, and requires more operations to arrive at the answer.</p>
<h3 id="a-compositional-tree-search">A Compositional Tree Search</h3>
<p>Going down the DRY path didn't return great results. What about reshaping the view of the problem. What if instead of a linear search of the problem space, a tree structure was used? How does FizzBuzz turn into a tree structure? With a fair amount of squinting and head turning.</p>
<p>Assuming a number is divisible by 3, how many possible answers to FizzBuzz are there? Two. It has to either be Fizz or FizzBuzz. Like wise if it wasn't divisible by 3, two answers are possible, the number or Buzz. After the first check the implementation can branch into a subspace of possible answers that remain.</p>
<p>If you're scratching your head, no worries the code is simpler:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">compositional_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">opti_buzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>        </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">5 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>            String::from(&quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;)
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            String::from(&quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">pessi_buzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>        </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">5 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>            String::from(&quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;)
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            num.</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if</span><span> num % </span><span style="color:#d08770;">3 </span><span>== </span><span style="color:#d08770;">0 </span><span>{
</span><span>        </span><span style="color:#96b5b4;">opti_buzz</span><span>(num)
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        </span><span style="color:#96b5b4;">pessi_buzz</span><span>(num)
</span><span>    }
</span><span>}
</span></code></pre>
<p>There are two sub-functions, &quot;Optimistic Buzz&quot; and &quot;Pessimistic Buzz&quot;. Each represents the possible solution space after determining if the number was divisible by 3. This implementation accomplishes removing the check for divisibility by 15, but does end up with additional repetition of syntax. How do the numbers look?</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Compositional</td><td style="text-align: left">0.407376408</td><td style="text-align: left">0.40918285</td><td style="text-align: left">0.397688</td><td style="text-align: left">0.4127639</td></tr>
</tbody></table>
<p>Finally, the brute of a dragon is slain. This implementation will always return an answer in 2 checks, and unlike the accumulative approach no extra computations were added in.</p>
<h3 id="matchbox-an-exercise-in-playing-with-syntax">Matchbox, an Exercise in Playing With Syntax</h3>
<p>The compositional tree search was a big win for FizzBuzz implementations everywhere. That implementation is not the sole way to implement such an idea. Consider the &quot;matchbox&quot; implementation:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">matchbox_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">match</span><span> num % </span><span style="color:#d08770;">3 </span><span>{
</span><span>        </span><span style="color:#d08770;">0 </span><span>=&gt; </span><span style="color:#b48ead;">match</span><span> num % </span><span style="color:#d08770;">5 </span><span>{
</span><span>            </span><span style="color:#d08770;">0 </span><span>=&gt; String::from(&quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;),
</span><span>            _ =&gt; String::from(&quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;),
</span><span>        },
</span><span>        _ =&gt; </span><span style="color:#b48ead;">match</span><span> num % </span><span style="color:#d08770;">5 </span><span>{
</span><span>            </span><span style="color:#d08770;">0 </span><span>=&gt; String::from(&quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;),
</span><span>            _ =&gt; num.</span><span style="color:#96b5b4;">to_string</span><span>(),
</span><span>        },
</span><span>    }
</span><span>}
</span></code></pre>
<p>It uses different syntax to express the same idea. One would expect similar performance to the compositional solution.</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Compositional</td><td style="text-align: left">0.407376408</td><td style="text-align: left">0.40918285</td><td style="text-align: left">0.397688</td><td style="text-align: left">0.4127639</td></tr>
<tr><td style="text-align: left">Matchbox</td><td style="text-align: left">0.409592448</td><td style="text-align: left">0.4123591</td><td style="text-align: left">0.3986988</td><td style="text-align: left">0.4176746</td></tr>
</tbody></table>
<p>One should also test their assumptions before deploying to production. Frankly, I am not an expert on the innards of Rust. One would have to dig into the assembly to determine what decisions the compiler made that lead to this disparity of results. While I could do that, I have paid sufficient dividends to my sunk cost of thinking about FizzBuzz and will leave this as an exercise for the reader. I decided it was useful to leave this here as a reminder that <a href="https://en.wikipedia.org/wiki/Animal_Farm">all syntax is equal, some are just more equal than others</a>.</p>
<h3 id="branchless-fizzbuzz">Branchless FizzBuzz</h3>
<p>One could declare victory now that the original brute algorithm has been usurped, but I will continue on. I once watched a talk from someone, who seemed to know what they were doing, talk about how branches are bad and branchless programs are good. I don't remember the points of the talk, but if I squint hard at my bit accumulating solution that looks like the bones of a branchless solution. Let's chuck a few more arrays in there for indexing answers from and that turns into:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">branchless_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">let</span><span> fizzdex = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>];
</span><span>    </span><span style="color:#b48ead;">let</span><span> buzzdex = [</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>];
</span><span>    </span><span style="color:#b48ead;">let</span><span> results = [&amp;num.</span><span style="color:#96b5b4;">to_string</span><span>(), &quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;];
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> idx = </span><span style="color:#d08770;">0</span><span>;
</span><span>    idx += fizzdex[(num % </span><span style="color:#d08770;">3</span><span>) as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>    idx += buzzdex[(num % </span><span style="color:#d08770;">5</span><span>) as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>    results[idx].</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>}
</span></code></pre>
<p>Implementation notes:</p>
<ul>
<li>Num % 3 has 3 possible answers, and num % 5 has 5 possible answers, that's where the lengths of the fizzdex and buzzdex arrays come from.</li>
<li>This implementation re-uses the same bit flag idea of representing FizzBuzz as the accumulative implementation.</li>
<li>The results array encodes the the number as a string unlike the accumulative implementations that determined that with a branch.</li>
</ul>
<p>How bad were the branches?</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Branchless</td><td style="text-align: left">0.83132986</td><td style="text-align: left">0.83125575</td><td style="text-align: left">0.829375</td><td style="text-align: left">0.8368611</td></tr>
</tbody></table>
<p>Ouch. That's consistent timing. Consistently bad. Our usual culprit, strings is at it again. The number is converted to a string on every computation of FizzBuzz instead of when required. No worries, let's smash some ideas from the compositional FizzBuzz solution in here and things will be all good.</p>
<h3 id="a-smart-branchless-fizzbuzz">A Smart(?) Branchless FizzBuzz</h3>
<p>The compisitional FizzBuzz contained different possible solution spaces to individual functions. Likewise the cost of converting the number to a string can be contained into a function. How is that done without branching? More arrays.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">smartbranchless_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">fizzbuzz_answer</span><span>(</span><span style="color:#bf616a;">idx</span><span>: </span><span style="color:#b48ead;">usize</span><span>, </span><span style="color:#bf616a;">_num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>        </span><span style="color:#b48ead;">let</span><span> results: [&amp;</span><span style="color:#b48ead;">str</span><span>; </span><span style="color:#d08770;">4</span><span>] = [&quot;&quot;, &quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;];
</span><span>        results[idx].</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">num_answer</span><span>(</span><span style="color:#bf616a;">_idx</span><span>: </span><span style="color:#b48ead;">usize</span><span>, </span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>        num.</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> fizzdex = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>];
</span><span>    </span><span style="color:#b48ead;">let</span><span> buzzdex = [</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>];
</span><span>    </span><span style="color:#b48ead;">let</span><span> results = [
</span><span>        num_answer,
</span><span>        fizzbuzz_answer,
</span><span>        fizzbuzz_answer,
</span><span>        fizzbuzz_answer,
</span><span>    ];
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> idx = </span><span style="color:#d08770;">0</span><span>;
</span><span>    idx += fizzdex[(num % </span><span style="color:#d08770;">3</span><span>) as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>    idx += buzzdex[(num % </span><span style="color:#d08770;">5</span><span>) as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>    results[idx](idx, num)
</span><span>}
</span><span>
</span></code></pre>
<p>The answers are now contained in functions, which are chosen based on indexing into an array. The decision of which function to calls lines up with the original result array. If index is 0, then the number must be converted to a string. In all other situations the array of possible Fizz/Buzz answers is used.</p>
<p>What's the performance?</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Branchless</td><td style="text-align: left">0.83132986</td><td style="text-align: left">0.83125575</td><td style="text-align: left">0.829375</td><td style="text-align: left">0.8368611</td></tr>
<tr><td style="text-align: left">Smart Branchless</td><td style="text-align: left">0.463881771</td><td style="text-align: left">0.4621437</td><td style="text-align: left">0.4559619</td><td style="text-align: left">0.4776058</td></tr>
</tbody></table>
<p>It would appear cleverness, while worthy of accolades during code review, is a waste of CPU cycles. Alright, maybe we should give up and branch.</p>
<h3 id="branchful-fizzbuzz">Branchful FizzBuzz</h3>
<p>Instead of containing the number conversion to a function that is selected via array indexing let's branch:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">branchful_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">let</span><span> results: [&amp;</span><span style="color:#b48ead;">str</span><span>; </span><span style="color:#d08770;">4</span><span>] = [&quot;&quot;, &quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;];
</span><span>    </span><span style="color:#b48ead;">let</span><span> fizzdex = [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>];
</span><span>    </span><span style="color:#b48ead;">let</span><span> buzzdex = [</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>];
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> idx = </span><span style="color:#d08770;">0</span><span>;
</span><span>    idx += fizzdex[(num % </span><span style="color:#d08770;">3</span><span>) as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>    idx += buzzdex[(num % </span><span style="color:#d08770;">5</span><span>) as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>    </span><span style="color:#b48ead;">if</span><span> idx == </span><span style="color:#d08770;">0 </span><span>{
</span><span>        num.</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        results[idx].</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<p>There, I've de-clevered. How does this compare?</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Branchless</td><td style="text-align: left">0.83132986</td><td style="text-align: left">0.83125575</td><td style="text-align: left">0.829375</td><td style="text-align: left">0.8368611</td></tr>
<tr><td style="text-align: left">Smart Branchless</td><td style="text-align: left">0.463881771</td><td style="text-align: left">0.4621437</td><td style="text-align: left">0.4559619</td><td style="text-align: left">0.4776058</td></tr>
<tr><td style="text-align: left">Branchful</td><td style="text-align: left">0.444799967</td><td style="text-align: left">0.4447638</td><td style="text-align: left">0.4416377</td><td style="text-align: left">0.4489821</td></tr>
</tbody></table>
<p>Branches perform better than clever indexing it would seem. In fact, all these are slower than the number from the bit accumulation implementation.</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Bit Accumulate</td><td style="text-align: left">0.431947604</td><td style="text-align: left">0.4321037</td><td style="text-align: left">0.4271722</td><td style="text-align: left">0.4353882</td></tr>
</tbody></table>
<p>The reality is that modern computers are well optimized for common programming constructs including branching. There are <a href="https://en.wikipedia.org/wiki/Branch_predictor">branch predictors</a> and <a href="https://en.wikipedia.org/wiki/Speculative_execution">speculative execution</a>. Modern computers are actually a little <a href="https://meltdownattack.com/">too eager to help us</a>. There was a time and place for cleverness such as <a href="https://en.wikipedia.org/wiki/Duff%27s_device">Duff's device</a>. Modern machines and compilers encourage sane programs with common constructs. Which is good news to my ears.</p>
<h3 id="doof-fizzbuzz">Doof FizzBuzz</h3>
<p>Now I would be remissed in a collection of FizzBuzz implementations to not include an implementation in honor of the time that I, erm, Dr. Doofenshmirtz forgot that the modulus operator existed. Presenting, the modulus-less FizzBuzz:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">doof_fizzbuzz</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; String {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">doof_mod</span><span>(</span><span style="color:#bf616a;">num</span><span>: </span><span style="color:#b48ead;">u32</span><span>, </span><span style="color:#bf616a;">check</span><span>: </span><span style="color:#b48ead;">u32</span><span>) -&gt; </span><span style="color:#b48ead;">bool </span><span>{
</span><span>        </span><span style="color:#b48ead;">let</span><span> div = num / check;
</span><span>        (div * check) == num
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">doof_mod</span><span>(num, </span><span style="color:#d08770;">15</span><span>) {
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">FizzBuzz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else if </span><span style="color:#96b5b4;">doof_mod</span><span>(num, </span><span style="color:#d08770;">3</span><span>) {
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">Fizz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else if </span><span style="color:#96b5b4;">doof_mod</span><span>(num, </span><span style="color:#d08770;">5</span><span>) {
</span><span>        String::from(&quot;</span><span style="color:#a3be8c;">Buzz</span><span>&quot;)
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        num.</span><span style="color:#96b5b4;">to_string</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<p>You laugh, but:</p>
<table><thead><tr><th style="text-align: left">FizzBuzz</th><th style="text-align: left">Avg</th><th style="text-align: left">Median</th><th style="text-align: left">Min</th><th style="text-align: left">Max</th></tr></thead><tbody>
<tr><td style="text-align: left">Brute</td><td style="text-align: left">0.408333959</td><td style="text-align: left">0.41058575</td><td style="text-align: left">0.39908</td><td style="text-align: left">0.4158568</td></tr>
<tr><td style="text-align: left">Doof</td><td style="text-align: left">0.409001909</td><td style="text-align: left">0.4107218</td><td style="text-align: left">0.4009717</td><td style="text-align: left">0.413815</td></tr>
</tbody></table>
<p>No record breaking results, but it preformed better than most. Turns out there are worse mistakes you can make than reinventing a basic operator.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Congratulations on successfully navigating to the end of these unmerited ramblings on an introductory programming problem. I think these findings reaffirm sage words from Donald Knuth:</p>
<blockquote>
<p>We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.</p>
</blockquote>

          </div>
        </article>
      </div>
      
    </div>
  </div>
</section>


  
  <section class="modal" id="search-modal">
    <div class="modal-background"></div>
    <div class="modal-card">
      <header class="modal-card-head">
        <p class="modal-card-title">Search</p>
      </header>
      <section class="modal-card-body">
        <div class="field mb-2">
          <div class="control">
            <input class="input" id="search" placeholder="Search this website." type="search" />
          </div>
        </div>
        <div class="search-results">
          <div class="search-results__items"></div>
        </div>
      </section>
    </div>
    <button aria-label="close" class="modal-close is-large"></button>
  </section>
  


  

<section class="section">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-8">
        <nav class="level">
              
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;www.andrewadriance.com&#x2F;posts&#x2F;helloworld&#x2F;">
              <span class="icon mr-2">
                <i class="fas fa-arrow-circle-left"></i>
              </span>
              Hello World!
            </a>
          </div>
           
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;www.andrewadriance.com&#x2F;posts&#x2F;yakshavineditorzen&#x2F;">
              A Programmers Zen Garden: Yak Shaving Your Text Editor<span class="icon ml-2">
                <i class="fas fa-arrow-circle-right"></i>
              </span>
            </a>
          </div>
          
        </nav>
      </div>
    </div>
  </div>
</section>



  



  
  <footer class="footer py-4">
    <div class="content has-text-centered">
      <p>
        Built with
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-code"></i>
          </span>
          <span>code</span>
        </span>
        and
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-heart"></i>
          </span>
          <span>love</span>
        </span>
      </p>
      <p>
        Powered by
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-power-off"></i>
          </span>
          <span>zola</span>
        </span>
      </p>
    </div>
  </footer>
  

  
  
  
  
  <script src="https://www.andrewadriance.com/elasticlunr.min.js"></script>
  <script src="https://www.andrewadriance.com/search_index.en.js"></script><script src="https://www.andrewadriance.com/js/site.js"></script>

  





  
  
</body>

</html>
